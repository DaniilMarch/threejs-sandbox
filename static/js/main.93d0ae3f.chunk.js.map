{"version":3,"sources":["scenes/sine.js","scenes/wrappers.js","scenes/test.js","scenes/anotherTest.js","scenes/utils.js","scenes/multiSine.js","scenes/ripple.js","scenes/cylinder.js","scenes/pulsingSphere.js","scenes/torus.js","scenes/wavySurface.js","scenes/index.js","components/CanvasWrapper.js","components/SceneSelection.js","actions/sceneActions.js","actions/types.js","reducers/sceneReducer.js","reducers/index.js","store/index.js","App.js","index.js"],"names":["SceneWrapper","args","this","scene","three","objects","frames","background","clearThree","obj","children","length","remove","geometry","dispose","material","Object","keys","forEach","prop","init","add","mesh","update","ObjectWrapper","updateFunc","initFunc","color","rotation","x","y","i","object","position","Math","sin","Date","now","startingTime","PI","r","g","push","createMeshGrid","resolution","boxSize","j","z","d","sqrt","getTimeSinceStart","getUVParameters","step","u","v","gridMesh","gridElement","cos","s","r1","r2","vertices","vertex","initialY","random","generateVerticesGrid","faces","n0","n1","n2","n3","face1","face2","generateFacesFromVertices","computeFaceNormals","computeVertexNormals","edgeGeometry","edgeMaterial","linewidth","wireframe","referenceGeometry","test","anotherTest","sine","multiSine","ripple","cylinder","pulsingSphere","torus","wavy","phaseShift","freq","initialTime","verticesNeedUpdate","console","log","newGeometry","CanvasWrapper","props","animate","cachedScene","scenes","uuid","requestAnimationFrame","bind","state","renderer","render","camera","sceneKey","controls","wrapperRef","React","createRef","antialias","setPixelRatio","window","devicePixelRatio","setSize","current","clientWidth","clientHeight","appendChild","domElement","OrbitControls","setState","prevProps","prevState","className","ref","Component","StyledWrapper","styled","connect","StyledSceneSelection","switchScene","htmlFor","id","name","onChange","event","target","value","map","key","index","type","payload","initialState","sceneReducer","action","combineReducers","store","createStore","reducers","__REDUX_DEVTOOLS_EXTENSION__","App","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.93d0ae3f.chunk.js","sourcesContent":["import * as three from \"three\";\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\n\r\nconst objects = [];\r\n\r\nconst resolution = 10;\r\nconst boxSize = 2 / resolution;\r\n\r\nfor (let i = 0; i < resolution; i++) {\r\n  const geometry = new three.BoxGeometry(boxSize, boxSize, boxSize);\r\n  const material = new three.MeshBasicMaterial({ color: 0xffffff });\r\n  const mesh = new three.Mesh(geometry, material);\r\n\r\n  const updateFunc = mesh => {\r\n    mesh.position.y = Math.sin(\r\n      ((Date.now() - mesh.startingTime) / 1000 + mesh.position.x) * Math.PI\r\n    );\r\n    mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n    mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n  };\r\n\r\n  const initFunc = mesh => {\r\n    mesh.position.x = i * boxSize;\r\n    mesh.startingTime = Date.now();\r\n  };\r\n\r\n  const object = new ObjectWrapper({ mesh, updateFunc, initFunc });\r\n\r\n  objects.push(object);\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nexport const clearThree = obj => {\r\n  while (obj.children.length > 0) {\r\n    clearThree(obj.children[0]);\r\n    obj.remove(obj.children[0]);\r\n  }\r\n  if (obj.geometry) obj.geometry.dispose();\r\n\r\n  if (obj.material) {\r\n    Object.keys(obj.material).forEach(prop => {\r\n      if (!obj.material[prop]) return;\r\n      if (typeof obj.material[prop].dispose === \"function\")\r\n        obj.material[prop].dispose();\r\n    });\r\n    obj.material.dispose();\r\n  }\r\n};\r\n\r\nexport class SceneWrapper {\r\n  constructor(args) {\r\n    this.scene = new three.Scene();\r\n    this.objects = args.objects;\r\n    this.frames = 0;\r\n    if (args.background) {\r\n      this.scene.background = args.background;\r\n    }\r\n  }\r\n  init() {\r\n    clearThree(this.scene);\r\n\r\n    this.objects.forEach(obj => {\r\n      obj.init();\r\n      this.scene.add(obj.mesh);\r\n    });\r\n  }\r\n  update() {\r\n    this.objects.forEach(obj => {\r\n      obj.update();\r\n    });\r\n    this.frames += 1;\r\n  }\r\n}\r\n\r\nexport class ObjectWrapper {\r\n  constructor(args) {\r\n    this.mesh = args.mesh;\r\n    this.updateFunc = args.updateFunc;\r\n    this.initFunc = args.initFunc;\r\n  }\r\n\r\n  update() {\r\n    this.updateFunc(this.mesh);\r\n  }\r\n  init() {\r\n    this.initFunc(this.mesh);\r\n  }\r\n}\r\n","import * as three from \"three\";\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\n\r\nconst geometry = new three.BoxGeometry(1, 1, 1);\r\nconst material = new three.MeshBasicMaterial({ color: 0xff0000 });\r\nconst mesh = new three.Mesh(geometry, material);\r\n\r\nconst otherTestObjects = [\r\n  new ObjectWrapper({\r\n    mesh,\r\n    updateFunc: mesh => {\r\n      mesh.rotation.x += 0.01;\r\n      mesh.rotation.y += 0.01;\r\n    },\r\n    initFunc: mesh => {\r\n      mesh.rotation.x = 0;\r\n      mesh.rotation.y = 0;\r\n    }\r\n  })\r\n];\r\n\r\nconst scene = new SceneWrapper({ objects: otherTestObjects });\r\n\r\nexport default scene;\r\n","import * as three from \"three\";\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\n\r\nconst geometry = new three.BoxGeometry(1, 1, 1);\r\nconst material = new three.MeshBasicMaterial({ color: 0x00ff00 });\r\nconst mesh = new three.Mesh(geometry, material);\r\n\r\nconst otherTestObjects = [\r\n  new ObjectWrapper({\r\n    mesh: mesh,\r\n    updateFunc: mesh => {\r\n      mesh.rotation.x += 0.01;\r\n      mesh.rotation.y += 0.01;\r\n    },\r\n    initFunc: mesh => {\r\n      mesh.rotation.x = 0;\r\n      mesh.rotation.y = 0;\r\n    }\r\n  })\r\n];\r\n\r\nconst scene = new SceneWrapper({ objects: otherTestObjects });\r\n\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nexport const createMeshGrid = resolution => {\r\n  const boxSize = 2 / resolution;\r\n  const objects = [];\r\n  for (let i = 0; i < resolution; i++) {\r\n    for (let j = 0; j < resolution; j++) {\r\n      const initFunc = mesh => {\r\n        mesh.position.x = (i + 0.5) * boxSize - 1;\r\n        mesh.position.z = (j + 0.5) * boxSize - 1;\r\n        mesh.startingTime = Date.now();\r\n        mesh.d = Math.sqrt(\r\n          mesh.position.x * mesh.position.x + mesh.position.z * mesh.position.z\r\n        );\r\n        mesh.boxSize = boxSize;\r\n        mesh.i = i;\r\n        mesh.j = j;\r\n      };\r\n      const geometry = new three.BoxGeometry(boxSize, boxSize, boxSize);\r\n      const material = new three.MeshBasicMaterial({ color: 0xffffff });\r\n      const mesh = new three.Mesh(geometry, material);\r\n      objects.push({ mesh, initFunc });\r\n    }\r\n  }\r\n  return objects;\r\n};\r\n\r\nexport const getTimeSinceStart = startingTime => {\r\n  return (Date.now() - startingTime) / 1000;\r\n};\r\n\r\nexport const getUVParameters = (i, j, step) => {\r\n  const u = (i + 0.5) * step - 1;\r\n  const v = (j + 0.5) * step - 1;\r\n  return { u, v };\r\n};\r\n\r\nexport const sinh = x => {\r\n  return (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2;\r\n};\r\n\r\nexport const cosh = x => {\r\n  return (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2;\r\n};\r\n\r\nexport const generateVerticesGrid = resolution => {\r\n  const step = 2 / resolution;\r\n  const vertices = [];\r\n  for (let i = 0; i < resolution; i++) {\r\n    for (let j = 0; j < resolution; j++) {\r\n      const vertex = new three.Vector3(i * step, 0, j * step);\r\n      vertex.initialY = (Math.random() * (Math.random() > 0.5 ? -1 : 1)) / 10;\r\n      vertices.push(vertex);\r\n    }\r\n  }\r\n  return vertices;\r\n};\r\n\r\nexport const generateFacesFromVertices = resolution => {\r\n  const faces = [];\r\n  for (let j = 0; j < resolution - 1; j++) {\r\n    for (let i = 0; i < resolution - 1; i++) {\r\n      const n0 = j * resolution + i;\r\n      const n1 = n0 + 1;\r\n      const n2 = (j + 1) * resolution + i + 1;\r\n      const n3 = n2 - 1;\r\n      const face1 = new three.Face3(n0, n1, n2);\r\n      const face2 = new three.Face3(n2, n3, n0);\r\n      faces.push(face1);\r\n      faces.push(face2);\r\n    }\r\n  }\r\n  return faces;\r\n};\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport { createMeshGrid } from \"./utils\";\r\n\r\nconst objects = [];\r\nconst gridMesh = createMeshGrid(20);\r\n\r\nfor (let gridElement of gridMesh) {\r\n  objects.push(\r\n    new ObjectWrapper({\r\n      mesh: gridElement.mesh,\r\n      initFunc: gridElement.initFunc,\r\n      updateFunc: mesh => {\r\n        mesh.position.y = Math.sin(\r\n          ((Date.now() - mesh.startingTime) / 1000 + mesh.position.x) * Math.PI\r\n        );\r\n        mesh.position.y += Math.sin(\r\n          ((Date.now() - mesh.startingTime) / 1000 + mesh.position.z) * Math.PI\r\n        );\r\n        mesh.position.y *= 0.5;\r\n        mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n        mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport { createMeshGrid } from \"./utils\";\r\n\r\nconst objects = [];\r\nconst gridMesh = createMeshGrid(20);\r\n\r\nfor (let gridElement of gridMesh) {\r\n  objects.push(\r\n    new ObjectWrapper({\r\n      mesh: gridElement.mesh,\r\n      initFunc: gridElement.initFunc,\r\n      updateFunc: mesh => {\r\n        mesh.position.y = Math.sin(\r\n          Math.PI * (4 * mesh.d - (Date.now() - mesh.startingTime) / 1000)\r\n        );\r\n        mesh.position.y /= 1 + 10 * mesh.d;\r\n        mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n        mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport { createMeshGrid, getTimeSinceStart, getUVParameters } from \"./utils\";\r\n\r\nconst objects = [];\r\nconst gridMesh = createMeshGrid(50);\r\n\r\nfor (let gridElement of gridMesh) {\r\n  objects.push(\r\n    new ObjectWrapper({\r\n      mesh: gridElement.mesh,\r\n      initFunc: gridElement.initFunc,\r\n      updateFunc: mesh => {\r\n        const { u, v } = getUVParameters(mesh.i, mesh.j, mesh.boxSize);\r\n        const r =\r\n          0.8 +\r\n          Math.sin(\r\n            Math.PI * (6 * u + 2 * v + getTimeSinceStart(mesh.startingTime))\r\n          ) *\r\n            0.2;\r\n\r\n        mesh.position.x = r * Math.sin(Math.PI * u);\r\n        mesh.position.z = r * Math.cos(Math.PI * u);\r\n        mesh.position.y = v;\r\n\r\n        mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n        mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport { createMeshGrid, getTimeSinceStart, getUVParameters } from \"./utils\";\r\n\r\nconst objects = [];\r\nconst gridMesh = createMeshGrid(50);\r\n\r\nfor (let gridElement of gridMesh) {\r\n  objects.push(\r\n    new ObjectWrapper({\r\n      mesh: gridElement.mesh,\r\n      initFunc: gridElement.initFunc,\r\n      updateFunc: mesh => {\r\n        const { u, v } = getUVParameters(mesh.i, mesh.j, mesh.boxSize);\r\n        let r =\r\n          0.8 +\r\n          Math.sin(Math.PI * (6 * u + getTimeSinceStart(mesh.startingTime))) *\r\n            0.1 +\r\n          Math.sin(Math.PI * (4 * v + getTimeSinceStart(mesh.startingTime))) *\r\n            0.1;\r\n\r\n        const s = r * Math.cos(Math.PI * 0.5 * v);\r\n\r\n        mesh.position.x = s * Math.sin(Math.PI * u);\r\n        mesh.position.y = r * Math.sin(Math.PI * 0.5 * v);\r\n        mesh.position.z = s * Math.cos(Math.PI * u);\r\n\r\n        mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n        mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport { createMeshGrid, getTimeSinceStart, getUVParameters } from \"./utils\";\r\n\r\nconst objects = [];\r\nconst gridMesh = createMeshGrid(50);\r\n\r\nfor (let gridElement of gridMesh) {\r\n  objects.push(\r\n    new ObjectWrapper({\r\n      mesh: gridElement.mesh,\r\n      initFunc: gridElement.initFunc,\r\n      updateFunc: mesh => {\r\n        const { u, v } = getUVParameters(mesh.i, mesh.j, mesh.boxSize);\r\n        const r1 =\r\n          0.65 +\r\n          Math.sin(Math.PI * (6 * u + getTimeSinceStart(mesh.startingTime))) *\r\n            0.1;\r\n        const r2 =\r\n          0.2 +\r\n          Math.sin(Math.PI * (4 * v + getTimeSinceStart(mesh.startingTime))) *\r\n            0.05;\r\n\r\n        const s = r2 * Math.cos(Math.PI * v) + r1;\r\n\r\n        mesh.position.x = s * Math.sin(Math.PI * u);\r\n        mesh.position.y = r2 * Math.sin(Math.PI * v);\r\n        mesh.position.z = s * Math.cos(Math.PI * u);\r\n\r\n        mesh.material.color.r = mesh.position.y * 0.5 + 0.5;\r\n        mesh.material.color.g = mesh.position.x * 0.5 + 0.5;\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(\"rgb(140, 140, 140)\")\r\n});\r\nexport default scene;\r\n","import * as three from \"three\";\r\n\r\nimport { ObjectWrapper, SceneWrapper } from \"./wrappers\";\r\nimport {\r\n  getTimeSinceStart,\r\n  generateFacesFromVertices,\r\n  generateVerticesGrid\r\n} from \"./utils\";\r\n\r\nconst resolution = 10;\r\nconst step = 2 / resolution;\r\n\r\nconst geometry = new three.Geometry();\r\n\r\nconst vertices = generateVerticesGrid(resolution);\r\nconst faces = generateFacesFromVertices(resolution);\r\n\r\ngeometry.vertices.push(...vertices);\r\ngeometry.faces.push(...faces);\r\ngeometry.computeFaceNormals();\r\ngeometry.computeVertexNormals();\r\n\r\nconst material = new three.MeshBasicMaterial({ color: 0xff7370 });\r\n\r\nconst mesh = new three.Mesh(geometry, material);\r\n\r\nconst edgeGeometry = new three.WireframeGeometry(mesh.geometry);\r\nconst edgeMaterial = new three.LineBasicMaterial({\r\n  color: 0x000000,\r\n  linewidth: 2\r\n});\r\nconst wireframe = new three.LineSegments(edgeGeometry, edgeMaterial);\r\nwireframe.referenceGeometry = geometry;\r\n\r\nconst objects = [\r\n  new ObjectWrapper({\r\n    mesh,\r\n    initFunc: mesh => {\r\n      for (let vertex of mesh.geometry.vertices) {\r\n        vertex.y = vertex.initialY;\r\n        vertex.phaseShift = Math.random();\r\n        vertex.freq = Math.random();\r\n      }\r\n      mesh.initialTime = Date.now();\r\n    },\r\n    updateFunc: mesh => {\r\n      for (let vertex of mesh.geometry.vertices) {\r\n        vertex.y =\r\n          vertex.initialY +\r\n          Math.sin(\r\n            Math.PI *\r\n              (getTimeSinceStart(mesh.initialTime) * vertex.freq +\r\n                vertex.phaseShift)\r\n          ) /\r\n            resolution;\r\n      }\r\n      mesh.geometry.verticesNeedUpdate = true;\r\n    }\r\n  }),\r\n  new ObjectWrapper({\r\n    mesh: wireframe,\r\n    initFunc: mesh => {\r\n      console.log(mesh);\r\n    },\r\n    updateFunc: mesh => {\r\n      const newGeometry = new three.WireframeGeometry(mesh.referenceGeometry);\r\n      mesh.geometry = newGeometry;\r\n    }\r\n  })\r\n];\r\n\r\nconst scene = new SceneWrapper({\r\n  objects,\r\n  background: new three.Color(0xffffff)\r\n});\r\n\r\nexport default scene;\r\n","import test from \"./test\";\r\nimport anotherTest from \"./anotherTest\";\r\nimport sine from \"./sine\";\r\nimport multiSine from \"./multiSine\";\r\nimport ripple from \"./ripple\";\r\nimport cylinder from \"./cylinder\";\r\nimport pulsingSphere from \"./pulsingSphere\";\r\nimport torus from \"./torus\";\r\nimport wavy from \"./wavySurface\";\r\n\r\nexport default {\r\n  //test scene\r\n  test,\r\n  anotherTest,\r\n  sine,\r\n  multiSine,\r\n  ripple,\r\n  cylinder,\r\n  pulsingSphere,\r\n  torus,\r\n  wavy\r\n};\r\n","import React from \"react\";\r\nimport * as three from \"three\";\r\nimport styled from \"styled-components\";\r\nimport { connect } from \"react-redux\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n\r\nimport scenes from \"../scenes\";\r\n\r\nclass CanvasWrapper extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      renderer: null,\r\n      camera: null,\r\n      scene: null,\r\n      sceneKey: \"test\",\r\n      controls: null,\r\n      wrapperRef: React.createRef()\r\n    };\r\n    this.wrapperRef = React.createRef();\r\n  }\r\n  componentDidMount() {\r\n    //create renderer\r\n    const renderer = new three.WebGLRenderer({ antialias: true });\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    renderer.setSize(\r\n      this.state.wrapperRef.current.clientWidth,\r\n      this.state.wrapperRef.current.clientHeight\r\n    );\r\n\r\n    //add renderer to DOM\r\n    this.state.wrapperRef.current.appendChild(renderer.domElement);\r\n\r\n    //create camera\r\n    const camera = new three.PerspectiveCamera(\r\n      75,\r\n      this.state.wrapperRef.current.clientWidth /\r\n        this.state.wrapperRef.current.clientHeight,\r\n      0.1,\r\n      1000\r\n    );\r\n    camera.position.z = 5;\r\n\r\n    //add controls\r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n    this.setState({ renderer, camera, controls });\r\n  }\r\n\r\n  animate = cachedScene => {\r\n    //take new scene from props\r\n    const scene = scenes[this.props.scene];\r\n    //if scene which was first rendered by this instance of animate (cachedScene)\r\n    //is not the same that new scene - end animation cycle\r\n    if (scene.scene.uuid !== cachedScene.scene.uuid) {\r\n      return;\r\n    }\r\n    //binding to pass cached scene deep\r\n    requestAnimationFrame(this.animate.bind(this, cachedScene));\r\n    this.state.renderer.render(scene.scene, this.state.camera);\r\n    scene.update();\r\n  };\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const scene = scenes[this.props.scene];\r\n    scene.init();\r\n    //if prev scene is the same as the new one dont call animate again\r\n    //and if not first update\r\n    if (prevState.camera && prevState.renderer) {\r\n      if (scenes[prevProps.scene].scene.uuid === scene.scene.uuid) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.animate(scene);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className={this.props.className} ref={this.state.wrapperRef}></div>\r\n    );\r\n  }\r\n}\r\n\r\nconst StyledWrapper = styled(CanvasWrapper)`\r\n  width: 100%;\r\n  height: 100vh;\r\n  canvas {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n`;\r\n\r\nconst mapStateToProps = state => ({ scene: state.scene });\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  {}\r\n)(StyledWrapper);\r\n","import React from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { connect } from \"react-redux\";\r\n\r\nimport scenes from \"../scenes\";\r\nimport { switchScene } from \"../actions/sceneActions\";\r\n\r\nconst SceneSelection = props => {\r\n  const { className, switchScene } = props;\r\n  return (\r\n    <div className={className}>\r\n      <label htmlFor=\"scene-select\">select scene: </label>\r\n      <select\r\n        id=\"scene-select\"\r\n        name=\"scene\"\r\n        onChange={event => switchScene(event.target.value)}\r\n      >\r\n        {Object.keys(scenes).map((key, index) => (\r\n          <option value={key} key={index}>\r\n            {key}\r\n          </option>\r\n        ))}\r\n      </select>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst StyledSceneSelection = styled(SceneSelection)`\r\n  position: fixed;\r\n  top: 0px;\r\n  right: 0px;\r\n  background-color: #fff;\r\n`;\r\n\r\nconst mapStateToProps = state => ({});\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  { switchScene }\r\n)(StyledSceneSelection);\r\n","import { SWITCH_SCENE } from \"./types\";\r\n\r\nexport const switchScene = scene => ({ type: SWITCH_SCENE, payload: scene });\r\n","export const SWITCH_SCENE = \"SWITCH_SCENE\";\r\n","import { SWITCH_SCENE } from \"../actions/types\";\r\n\r\nimport scenes from \"../scenes/index\";\r\n\r\nconst initialState = Object.keys(scenes)[0];\r\n\r\nconst sceneReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case SWITCH_SCENE:\r\n      return action.payload;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport default sceneReducer;\r\n","import { combineReducers } from \"redux\";\r\n\r\nimport sceneReducer from \"./sceneReducer\";\r\n\r\nexport default combineReducers({\r\n  test: () => 5,\r\n  scene: sceneReducer\r\n});\r\n","import { createStore } from \"redux\";\r\n\r\nimport reducers from \"../reducers/index\";\r\n\r\nconst store = createStore(\r\n  reducers,\r\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);\r\n\r\nexport default store;\r\n","import React from \"react\";\nimport \"normalize.css\";\nimport { Provider } from \"react-redux\";\n\nimport CanvasWrapper from \"./components/CanvasWrapper\";\nimport SceneSelection from \"./components/SceneSelection\";\nimport store from \"./store\";\n\nconst App = () => {\n  return (\n    <Provider store={store}>\n      <CanvasWrapper />\n      <SceneSelection></SceneSelection>\n    </Provider>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}